## 并发

### 介绍

在进程的内部有一种东西叫做线程，如果我们单纯地将进程理解为一道程序的执行和这道程序所占有的空间，那么线程就可以直接理解为是这道进程的执行。就像函数要分主函数和其它函数一样，线程也可以分为主线程和其它线程，每个线程都只执行自己的任务。

线程与进程的主要区别是，同一个进程中的多个线程是共享内存堆空间的，也就是每个线程都可以使用同一块内存。另外，线程有自己的线程控制块，程序计数器以及各种寄存器（当然这有可能是假象，不过虚拟化会处理好这一切）。线程的切换也涉及到上下文切换，不过不需要切换页表。

线程有自己的栈，可以保证有些空间只有线程自己使用，虽然多余的栈造成了地址空间管理的复杂性，不过所幸栈一般不会太大。下图是单线程和多线程的地址空间：

![地址空间](img4/01.png)

#### 实例

```c
#include <stdio.h> 
#include <assert.h> 
#include <pthread.h> 

// 线程执行的函数
void *mythread(void *arg) { 
    printf("%s\n", (char *) arg); // 打印传递给线程的参数
    return NULL; 
} 

int main(int argc, char *argv[]) { 
    pthread_t p1, p2; // 声明线程标识符
    int rc; // 用于存储返回码

    printf("main: begin\n"); // 表示主函数开始

    // 创建第一个线程，传递"A"作为参数
    rc = pthread_create(&p1, NULL, mythread, "A"); 
    assert(rc == 0); // 确保线程创建成功

    // 创建第二个线程，传递"B"作为参数
    rc = pthread_create(&p2, NULL, mythread, "B"); 
    assert(rc == 0); // 确保线程创建成功

    // 等待第一个线程结束
    rc = pthread_join(p1, NULL); 
    assert(rc == 0); // 确保连接成功

    // 等待第二个线程结束
    rc = pthread_join(p2, NULL); 
    assert(rc == 0); // 确保连接成功

    printf("main: end\n"); // 表示主函数结束
    return 0; 
}
```

如上图所示的案例，线程就像函数一样，需要创建和执行，并且可以肯定的是，无论是主线程还是这些分支线程，都是串行执行的，只不过为了保证能看到每个线程及时出效果，我们让这些线程快速地轮转执行，看起来就像是同时执行一样。

这样带来一个问题，那就是对于每个线程执行的任务来说，你不知道它们执行的顺序，可能是第一个先执行完，也可能是第二个先执行外，或者其中一个执行的过程中突然中断，让另一个去执行的。这种无序性会让某些共享空间变得异常混乱。


#### 并发下共享数据的问题

```c
#include <stdio.h> 
#include <pthread.h> 
#include "mythreads.h" 

// volatile告诉编译器不要对这个变量进行优化，每次从内存读写变量值而不是缓存中
static volatile int counter = 0; // 定义一个可变的计数器

// 线程函数 mythread()
void * mythread(void *arg) { 
    printf("%s: begin\n", (char *) arg); // 打印线程开始信息
    int i; 
    // 循环增加计数器
    for (i = 0; i < 1e7; i++) { 
        counter = counter + 1; // 增加计数器
    } 
    printf("%s: done\n", (char *) arg); // 打印线程完成信息
    return NULL; 
} 

// 主函数 main()
int main(int argc, char *argv[]) { 
    pthread_t p1, p2; // 声明两个线程
    printf("main: begin (counter = %d)\n", counter); // 打印主函数开始信息

    // 创建两个线程
    Pthread_create(&p1, NULL, mythread, "A"); 
    Pthread_create(&p2, NULL, mythread, "B"); 

    // 等待两个线程完成
    Pthread_join(p1, NULL); 
    Pthread_join(p2, NULL); 
    printf("main: done with both (counter = %d)\n", counter); // 打印主函数结束信息
    return 0; 
}
```

上面的代码希望A线程和B线程分别对变量counter加10000000，最后得到结果20000000。

实际上结果一般不会是20000000，应该低于这个数字，原因就是线程的执行是无序的。

具体过程可以参考下例：

```mermaid
graph TB
A[counter值为100] --> B[A读取counter并装入寄存器];
B --> C[A取出counter值进行运算并将结果101写入寄存器];
C --> D[发生中断，接下来执行B线程];
D --> E[B读取counter值100，运算后将101写回内存];
E --> F[中断，执行A线程，A将之前计算的结果101写回内存]
```

可以看到，两个线程完全遵循串行执行，但由于对counter的读取写回操作不是原子的，导致它们分别读取和运算了相同的值，导致两次运算的效果等同于一次运算。

上述过程的中断发生在下面的指令执行过程中：

```C
mov 0x8049a1c, %eax  
add $0x1, %eax 
mov %eax, 0x8049a1c
```

如果不希望共享变量出现这种混乱，就要保证这三条指令必须在一起执行。


在之后的学习中，我们需要解决并发带来的这些问题，在此之前，我们有必要先了解一些基础概念。

- 临界区(critical section)：是访问共享资源的代码，上例中线程对counter进行读取运算部分的代码就是临界区。

- 竞态条件(race condition)：上例中两个线程竞争counter导致了错误的结果，这就是竞态条件。

- 不确定性(indeterminate)：counter的结果是不确定的，这就是不确定性。

- 互斥(mutual exclusion)原语：我们希望将三条执行运算的指令浓缩为一条，这一条就是互斥原语。

### 一些线程API

接下来的内容涉及到大量的并发代码，因此有必要介绍一些基本的线程API来增进理解。

**(1) pthread_create()**

该函数用来创建线程并执行。

```c
#include <pthread.h>  

int pthread_create(
    pthread_t *thread,                // 线程标识符的指针
    const pthread_attr_t *attr,      // 线程属性，NULL 表示使用默认属性
    void *(*start_routine)(void*),   // 线程执行的函数
    void *arg                         // 传递给线程函数的参数
);

// void* 可以转换为任意类型，推荐使用void*
```

**(2) pthread_join()**

该函数用于等待一个线程执行完成。



