## 虚拟化的实现

### 虚拟化的目的

将CPU虚拟化是为了让每一个进程都能持有一个CPU，保证在同一时间内多个进程看起来都能同时运行。

比如一边在后台播放音乐，一边打游戏。如果CPU不进行虚拟化就只能保证光听音乐或者光打游戏了。

### 实现虚拟化

#### 实现虚拟化的前提条件

虚拟化后的CPU必须保证高性能和安全控制。也就是较快的处理速度，以及控制进程确保进程不会做出违规操作。

实现虚拟化通过分离内核态用户态和中断实现。

---

进程一般在用户态启动，当需要访问一些文件或者进行IO等特殊操作时，需要转入内核态。

转入内核态的方式是中断。进程调用操作系统程序，会陷入中断，此时进程的寄存器状态字等内容会保存在内存中或者内存的堆栈中，然后操作系统执行中断处理程序。

> 系统调用程序和中断处理程序都是用汇编提前写好并保存在内存某处。

中断处理程序会进行进程想要的操作，比如访问文件或者执行IO。

完成后操作系统将进程的状态字寄存器等恢复，进入用户态，从上一次进程中断时的程序开始执行。

---

#### 实现虚拟化的方法

物理CPU只有一个，要把CPU虚拟化成多个，最直接的方式就是让CPU在不同的时间段处理不同的进程，当然速度要非常快，快到人的知觉反应不过来才行。

一个进程运行一段时间，陷入中断，然后操作系统控制CPU去执行另一个进程，然后这个进程执行一段时间后再陷入中断，再去执行另一个进程，循环往复，就实现了CPU的虚拟化。

---

这个过程中有两个问题，一是如何进行中断？二是如何切换到另一个进程？

首先是第一个问题。

中断方式有两样，早期的计算机设计时采用协作中断，也就是让一个进程运行一段时间后自己主动做一个特殊权限的操作让CPU陷入内核态，因为进程本身是用户态的，内核态只有操作系统能动，这样操作系统就有机会切换进程了。

> 有的人（比如我）可能会在一开始觉得操作系统就像幕后的一双手一样，协调控制着每个软件的运行，监管所有进程的行为，就像经理指挥着员工一样。
>
> 但实际上操作系统也只是一个软件，一段程序，在CPU眼里它和其它程序没有什么区别，因此在CPU执行某个用户程序时，是感受不到操作系统的存在的，也无法运行操作系统。
>
> 原因很简单，CPU根据程序计数器给出的指令地址来一条条调用并执行指令，如果程序计数器不给出操作系统的指令地址，那CPU就没法执行操作系统这个软件了。

协作中断有一个缺点，那就是必须程序主动配合，如果程序不愿意配合，或者不进行特殊权限操作而是恶意循环，那就永远轮不到操作系统登场，也就无法切换进程了。

现在一般采用时钟中断，也就是每个进程运行一定时钟周期，然后在下一个时钟周期陷入中断，这样就能保证操作系统顺利出场并切换进程。

关于第二个问题，如何切换进程？其实很简单，让程序计数器的指针指向第二个进程的指令的地址，进程内核栈的指针指向第二个进程的内核栈，包括其它状态字，寄存器之类也是一样。这样CPU就开始处理第二个进程了。

> 所谓进程就是一个正在运行的程序，其成分就是自己的状态字，寄存器和控制的内存等以及CPU的处理行为。
>
> 程序的运行在物理意义上就是存储空间中一个个二进制为由0变成1，由1变成0。那么进程的切换也不过是在一块空间上进行二进制数的变换改成在另一块空间上进行二进制数变换而已。

进程切换的操作和一般的中断处理是类似的，CPU陷入内核态，操作系统保存原进程的寄存器和状态字，然后将新进程的寄存器和状态字恢复，完成一系列操作后恢复到用户态，这样就开始运行新进程了。