## 虚拟化的调度

> 温馨提示：本节中采用的示例均是指单核CPU，下载任务默认是全程占用CPU的任务（哪怕实际上不是如此）。

### 调度要解决的问题

调度是为了实现在虚拟化过程中CPU能保证高性能的运转，这里的高性能涉及两个方面的指标，一个是周转时间，一个是响应时间。

所谓周转时间就是程序从启动到完成的时间。想象一下原神5.0纳塔版本更新了，接下来你需要安装更新包，当你点击安装时程序启动，安装结束时程序完成，这中间的安装花费的时间就是周转时间。

对于响应时间最直接的理解就是计算机对于键盘或鼠标等外设输入作出反应的时间。比如在终端写一行命令，从敲下回车开始，到命令执行开始的时间就是响应时间。

---

在CPU虚拟化的讨论中周转时间和响应时间是矛盾的，其矛盾点在于当你要运行多个程序时，不能保证每个程序既能有最短周转时间，又能有最短响应时间。

举个例子，当你想要安装原神的更新包时，你希望CPU能一直处理安装程序，保证安装时间——或者说程序周转时间最短，但此时你突然发现因为长时间玩原神导致你耽搁了你的课程作业，现在需要你马上打开终端运行一段命令然后截图发到学习通。

如果你希望能马上就玩到原神，那最好让CPU一直运行原神的更新包安装程序，但现在你必须打开终端运行命令，运行命令是需要CPU去响应处理的，这部分响应程序的时间就要从下载原神的时间里扣，那么原神安装程序的周转时间就要增加，与之对应的是CPU能马上过来响应你的需求，保证你可以按时交作业。

如果你真的很喜欢玩原神，甚至一度成为了mxz，那你当然可以牺牲你在终端输入命令的响应时间，让你的CPU尽全力下载好你喜欢的原神。

### 调度方式

为了解决好先玩原神还是先交作业这样令人痛苦的问题，现代计算机专家们提供了很多优秀的调度方式。感谢这些专家，他们毫无疑问在这种问题上救了我们一命。

#### SJF - 最短任务优先

SJF的策略很简单，在已知程序运行时间的情况下，让同时到来的几个程序中消耗时间最短的那一个先运行，然后以此类推，这样就能保证周转时间最短了。

> 在安装游戏时尤其好用，如果我们想同时安装多个游戏时，我们当然希望CPU先尽快安装一个游戏，赶紧玩起来，剩下的游戏之后再说。


#### STCF - 最短完成时间优先

STCF是SJF的改进版，SJF要求多个程序同时开始，而STCF则不用。STCF可以让正在同时运行的几个程序中剩余完成时间最短的那一个先运行。

> 当你原神下载一半但已经感到不耐烦时，STCF支持你马上去安装一个小游戏打法一下时间。

#### RR - 轮转

SJF和STCF在周转时间上表现得很好，但在响应时间上则惨不忍睹，因为它们只会在完全运行完一个程序后才会运行下一个程序。

RR转为响应时间准备。RR让计算机每运行一个程序一段时间后就去运行下一个程序，也就是我们之前说的时钟中断方式更改进程。

> 就像某个北理工的学长在期末破防周中说的那样，光看球赛或者光看书实在是太枯燥了，如果能看一会儿书，然后看一会儿球赛，那样效率就很高了。RR就是这样的方式，它支持你在计算机上看一会儿球赛，然后翻个页面看一会儿电子书。


#### MLFQ - 多级反馈队列

不管是SJF、STCF还是RR，在使用时都有一个基本的要求，那就是知道任务运行的时间，但很多时候我们并不知道运行任务需要多久，比如你能说出你玩原神一次会玩多久吗？你不会玩上头吗？

MLFQ提供了一种方法让我们在不知道任务运行时间的情况下仍然能保证任务运转。

##### 基本规则

MLFQ将一组任务分配到多个优先级不同的队列中去，优先级较高的队列先运行，优先级较低的队列后运行，同一优先级的队列采用轮转方式运行。

一般来说，对响应时间要求高的任务被视为高优先级任务，对周转时间要求高的任务被视为低优先级任务。高优先级的任务使用IO时CPU会转到低优先级的任务上。

每个任务在刚运行时会被放在优先级最高的队列中，计算机会计算每个任务在队列中连续运行的时间（也就是一直占用CPU而不使用IO的时间），根据时间计算机会把交互性高的任务留在最优先队列里，交互性低的任务会留在次优先的队列里。

每一个队列都有自己的时间限制，全程占用CPU而不使用一点儿IO的任务会被分配到优先级最低的队列中。

> 显然，如果你又要使用终端敲代码，又要下载原神，那么MLFQ是一个不错的选择。

---

尽管这种方式能够保证我们即完成作业，又能下载好原神，但是还有一个问题，如果作业太多了怎么办。

想象一下，你需要开启多个终端运行指令，输完这个转向另一个终端再输入。对于MLFQ来说，它会优先运行你的终端命令，很巧的是你的终端程序恰好占满了优先级高的队列，每次运行完一个程序都会转去运行另一个程序，而不会下载原神，这可太糟糕了。

##### 调整优先级

显然你不希望自己的生活充满作业，原神也要玩起来。如果你想在作业多的情况下仍然下载好原神，那就需要调整下载任务的优先级。

你可以让这些任务在运行一段时间后重新恢复到最高优先级然后重新调整，这样就能保证每个任务都被运行到。

作业太多的问题解决了，但还有一个问题。有的程序是循环程序，需要你重复`输入-等待-再输入`这样的操作，这种程序看似是一个高交互性的程序，但对周转时间的需求也相当大，如果持续时间和原神的下载时间一样的话，那么就算其它作业完成了，为了运行这个循环程序也不得不牺牲下载原神的时间。

为了避免这种事情发生，需要对任务的优先级作出更仔细的判断。我们将队列计时的方式从记录时间片内的时间改为记录任务运行的总时间，每个任务在队列中存在的总时间受限制，超时就会降低优先级。

> 到了这一步，你总算能保证自己在完成作业后不久就能玩上原神了。

##### 规则总结

- 规则1：如果A的优先级 > B的优先级，运行A（不运行B）。
- 规则2：如果A的优先级 = B的优先级，轮转运行A和B。 
- 规则3：工作进入系统时，放在最高优先级（最上层队列）。 
- 规则 4：一旦工作用完了其在某一层中的时间配额（无论中间主动放弃了多少次CPU），就降低其优先级（移入低一级队列）。 
- 规则5：经过一段时间S，就将系统中所有工作重新加入最高优先级队列。 


#### 比例份额调度

之前的MLFQ已经是大部分操作系统进行调度的方式，比例份额调度专门适用于那些能确定分配资源比例的任务，比如虚拟机需要分配多少CPU和存储等问题。

比例份额的使用分为两种方式，彩票份额调度和步长份额调度。

##### 彩票调度

彩票调度让每个任务持有一定的彩票数，每个任务彩票数占总彩票数的比例就是每个任务的比例份额，计算机随机抽取一张彩票，然后运行持有该彩票的任务。

比如有A，B，C三个任务，A持有彩票1 ~ 100，B持有101 ~ 150，C持有151 ~ 250。操作系统运行随机数程序，得到一个数假设是129，那接下来就开始运行B任务。

由于彩票的选取是随机的，那么在任务运行时间较长的情况下，可以保证每个任务都按照事先分配好的比例完成。

还有一个优势是，内存中只需要记录任务的彩票数，任务列表，总彩票数，实现起来很简单。

缺点是如果任务运行时间短，就很难保证按照比例公平地分配时间片。

##### 步长调度

还是上述的A，B，C三个任务，我们将每个任务的彩票数用10000整除一次，就得到A，B，C三个任务的步长，分别是100，200，100。

在运行中，每个任务都有行程。最开始大家都没有运行，行程为0.每次运行时选取行程最短的哪一个，第一次随机选取A，A步长为100步，运行完成后行程加步长为100，然后B和C中随机选取C，运行后行程加100，最后是B，行程加200。

接下来从A和C中随机选C，C行程加100，以此类推，行程最少的运行。

这就保证了步长少的（实际上分配的资源比例多的）行程增加最少，运行的次数最多。

相比于彩票调度，步长调度可以让每个任务运行时间短时也能保证按照比例分配时间片，但是必须让每个任务同时进入进程队列运行，如果在运行一组任务中途加入一个新任务，那么新任务就会垄断所有资源。

##### 总结

两种调度方式都根据分配的资源决定任务的运行情况，方式类似于轮转，只不过是按比例的分配任务运行的时间片数量。

彩票调度简单，适合运行时间长的任务。步长调度复杂一些，适合同时运行或运行时间短的任务。

和轮转很像，但是可以根据用户自己的需求调正资源的分配，算是轮转的一种优化。

> 如果你没有把作业堆积到截止日期前，你可以分配给原神更多的资源，这样你可以写一会儿作业，然后玩很久原神。这样在截止日期来临之际，你会发现你的作业写的差不多了，同时你原神也玩爽了。

