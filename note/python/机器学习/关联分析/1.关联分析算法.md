# 关联分析算法

下面是GPT生成的一个 Apriori Algorithm 算法

```python
from itertools import combinations
import matplotlib.pyplot as plt
import numpy as np
import seaborn as sns

class Association(object):
    def __init__(self):
        self.data = [
            {'a', 'b', 'd', 'e'},
            {'b', 'c', 'd'},
            {'a', 'b', 'd', 'e'},
            {'a', 'c', 'd', 'e'},
            {'b', 'c', 'd', 'e'},
            {'b', 'd', 'e'},
            {'c', 'd'},
            {'a', 'b', 'c'},
            {'a', 'd', 'e'},
            {'b', 'd'}
        ]

    # 计算支持度
    def calculate_support(self, itemset, data):
        count = 0
        for transaction in data:
            if itemset.issubset(transaction):
                count += 1
        return count / len(data)


    # 生成频繁项集
    def apriori(self, data, min_support):
        single_items = set(item for transaction in data for item in transaction)
        current_itemsets = [{item} for item in single_items]
        frequent_itemsets = []

        while current_itemsets:
            next_itemsets = []
            itemset_support = {}

            for itemset in current_itemsets:
                support = self.calculate_support(set(itemset), data)
                if support >= min_support:
                    frequent_itemsets.append((set(itemset), support))
                    itemset_support[frozenset(itemset)] = support

            # 生成新的候选项集
            seen_itemsets = set()  # 用于去重
            for i in range(len(current_itemsets)):
                for j in range(i + 1, len(current_itemsets)):
                    union_set = set(current_itemsets[i]).union(current_itemsets[j])
                    # 检查候选项集是否有效并未重复
                    if len(union_set) == len(current_itemsets[0]) + 1 and frozenset(union_set) not in seen_itemsets:
                        next_itemsets.append(union_set)
                        seen_itemsets.add(frozenset(union_set))

            # 如果没有新的候选项集，则退出循环
            if not next_itemsets:
                break

            current_itemsets = list(map(set, next_itemsets))

        return frequent_itemsets

    # 生成关联规则
    def generate_rules(self, frequent_itemsets, min_confidence):
        rules = []
        for itemset, support in frequent_itemsets:
            if len(itemset) > 1:
                for i in range(1, len(itemset)):
                    for antecedent in combinations(itemset, i):
                        antecedent = set(antecedent)
                        consequent = itemset - antecedent
                        confidence = self.calculate_support(itemset, self.data) / self.calculate_support(antecedent, self.data)
                        if confidence >= min_confidence:
                            rules.append((antecedent, consequent, confidence))
        return rules

    # 绘制热力图
    def thermal_map(self, results, support_values, confidence_values):
        # 转换数据为二维数组形式
        heatmap_data_itemsets = np.zeros((len(support_values), len(confidence_values)))
        heatmap_data_rules = np.zeros((len(support_values), len(confidence_values)))

        for res in results:
            i = support_values.index(res["support"])
            j = confidence_values.index(res["confidence"])
            heatmap_data_itemsets[i, j] = res["frequent_itemsets_count"]
            heatmap_data_rules[i, j] = res["rules_count"]

        # 设置热力图风格
        sns.set()
        fig, axes = plt.subplots(1, 2, figsize=(15, 6))

        # 频繁项集数量热力图
        sns.heatmap(heatmap_data_itemsets, annot=True, fmt=".0f", xticklabels=confidence_values,
                    yticklabels=support_values, ax=axes[0])
        axes[0].set_title("Frequent Itemsets Count")
        axes[0].set_xlabel("Confidence")
        axes[0].set_ylabel("Support")

        # 规则数量热力图
        sns.heatmap(heatmap_data_rules, annot=True, fmt=".0f", xticklabels=confidence_values,
                    yticklabels=support_values, ax=axes[1])
        axes[1].set_title("Rules Count")
        axes[1].set_xlabel("Confidence")
        axes[1].set_ylabel("Support")

        plt.tight_layout()
        plt.show()

    # 绘制曲线图
    def line_chart(self, results, support_values, confidence_values):
        # 绘制曲线图
        plt.figure(figsize=(10, 6))

        for min_support in support_values:
            itemsets_counts = [res["frequent_itemsets_count"] for res in results if res["support"] == min_support]
            rules_counts = [res["rules_count"] for res in results if res["support"] == min_support]

            plt.plot(confidence_values, itemsets_counts, label=f"Itemsets (Support={min_support})", marker='o')
            plt.plot(confidence_values, rules_counts, label=f"Rules (Support={min_support})", linestyle='--',
                     marker='x')

        plt.title("Effect of Support and Confidence on Results")
        plt.xlabel("Confidence")
        plt.ylabel("Count")
        plt.legend()
        plt.grid()
        plt.show()

    def run(self):
        # 参数设置
        support_values = [0.1, 0.2, 0.3, 0.4, 0.5]
        confidence_values = [0.4, 0.5, 0.6, 0.7, 0.8]

        # 用于记录结果
        results = []

        for min_support in support_values:
            for min_confidence in confidence_values:
                frequent_itemsets = self.apriori(self.data, min_support)
                rules = self.generate_rules(frequent_itemsets, min_confidence)
                results.append({
                    "support": min_support,
                    "confidence": min_confidence,
                    "frequent_itemsets_count": len(frequent_itemsets),
                    "rules_count": len(rules)
                })

        self.thermal_map(results, support_values, confidence_values)

        self.line_chart(results, support_values, confidence_values)

if __name__ == '__main__':
    association = Association()
    association.run()


```

