## 检测cuda运行时的错误

### 使用宏函数检测错误

下面是一个用于检测错误的宏函数，定义在错误检测的头文件error_cuh中：

```cpp
#pragma once
#include <stdio.h>

#define CHECK(call)
do {
    // call是一个cuda的运行时API
	const cudaError_t error_code = call;

	if (error_code != cudaSuccess) {
		printf("CUDA Error:\n");
		printf("File: %s\n", __FILE__);  // 错误文件
		printf("Line: %d\n", __LINE__);  // 错误行
		printf("Error code: %d\n", error_code);  // 错误代号
		printf("Error text: %s\n", cudaGetErrorString(error_code));  // 文字描述
		exit(1);
	}
} while (0)
// 不使用do-while语句不安全，原因不作讨论
```
**这段代码在运行时发现有报错，经过AI更改后的代码如下：**

```cpp
#pragma once
#include <cuda_runtime.h> // 确保包含了cuda_runtime.h，因为cudaGetErrorString在那里定义

#define CHECK(call) do { \
    const cudaError_t error_code = (call); \
    if (error_code != cudaSuccess) { \
        fprintf(stderr, "CUDA Error:\n"); \
        fprintf(stderr, "File: %s\n", __FILE__); \
        fprintf(stderr, "Line: %d\n", __LINE__); \
        fprintf(stderr, "Error code: %d\n", error_code); \
        fprintf(stderr, "Error text: %s\n", cudaGetErrorString(error_code)); \
        exit(1); \
    } \
} while (0)
```


将cuda的运行时API放在CHECK宏函数中可以检测错误，不过首先要引入头文件。

```cpp
#include <error.cuh>
```
然后使用CHECK，下面是一些示例：

```cpp
CHECK(cudaMalloc((void **)&d_x, M));
CHECK(cudaMemcpy(d_x, h_x, M, cudaMemcpyDeviceToHost));
CHECK(cudaFree(d_x));
```

上面的方法可以检测运行时API，但不能检测核函数，因为核函数是void类型的。如果要检测核函数，需要在核函数调用后使用下面两行代码：

```cpp
CHECK(cudaGetLastError());  // 捕捉下一行语句之前的最后一个错误
CHECK(cudaDeviceSynchronize());  // 同步主机与设备（会消耗大量时间）
```

### 使用CUDA-MEMCHECK工具检测错误

CUDA 提供了名为CUDA-MEMCHECK的工具集,具体包括memcheck、racecheckinitcheck、synccheck共4个工具。它们可由可执行文件 cuda-memcheck 调用:

```bash
$cuda-memcheck --tool memcheck [options] app_name [options]
$cuda-memcheck --tool racecheck [options] app_name [options]
$cuda-memcheck --tool initcheck [options] app_name [options]
$cuda-memcheck --tool synccheck [options] app_name [options]
```

对于 memcheck 工具，可以简化为
```bash
$ cuda-memcheck [options] app_name [options]
```